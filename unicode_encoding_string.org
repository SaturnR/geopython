* კოდირების მეთოდები და სტრინგზე მოქმედებები

** უნიკოდი 
60 - წლებიდან ამერიკაში არსებობდა [[https://en.wikipedia.org/wiki/ASCII][ASCII]] (American Standard Code for Information Interchange) სიმბოლოების სტანდარტიზაციის მეთოდი, რომელსაც იყენებდნენ ტელეტაიპით 
ტექსტის გადაცემის დროს. ASCII-ში მოცემულია ინგლისური ანბანის დიდი და პატარა ასოები, ასევე 0-დან 9-მდე რიცხვები და დამატებითი სიმბოლოები როგორიცაა . , : ; []{} და ა.შ.
ისევე როგორც ამერიკაში, სხვა ქვეყნებშიც დაიწყეს ინფორმაციის მიმოცვლის საკუთარი სტანდარტების დამუშავება. მაგალითად იაპონიაში არსებობდა რამოდენიმე სტანდარტი და თვითონ 
იაპონურ კომპანიებს შორის ტექსტის ერთმანეთში დაგადზავნისას იქმნებოდა პრობლემები, სხვა რომ არღარაფერი ვთქვათ სხვა ქვეყანაში ტექსტის გაგზავნაზე. ინტერნეტის შექმნის 
მომენტში, 80 წლების ბოლოს გაჩნდა საერთაშორისო სტანდარტის შექმნის მოთხოვნა. ამის გამო 1991  წელს შიექმნა Unicode კონსორციუმი. რომლის მიზანი იყო შეექმნა ტექსტური 
ინფორმაციის კოდირების საერთაშორისო სტანდარტი. დღეისთვის უნიკოდი შეიცავს 128000 სიმბოლოს, თითქმის ნებისმიერ სიმბოლოს რაც კაცობრიობის ისტორისს მანძილზე არსებობდა და 
ცნობილია. 
სულ რამოდენიმე სიტყვით, უნიკოდი ეს არის მსოფლიოში არსებული ყველა ხელნაწერი სიმბოლოს (და არა მარტო) უნიფიცირების მეთოდი.
უნიკოდში ყოველ ხელნაწერ ელემენტს მინიჭებული აქვს გარკვეული რიგითი ნომერი. მაგალითად არაბული რიხვითი სიმბოლოები და ინგლისური 
ანბანის პირველი ასოები მოთავსებული უნიკოდის 128 მდე რიგში, ქართული 4304-დან 4337-მდე შუალედში, ჩინური ძირითადი 19968-დან 40959-მდე შუალედში, და ა.შ

#+BEGIN_SRC bash
მაგ:
0 - 48
1 - 49
2 - 50
. . .
9 - 57
. . .
A - 65
B - 66 
.
Z - 90
.
a - 97
b - 98
.
z - 122
. . .
ა - 4304
ბ - 4305
. . .
ჰ - 4336
. . .
#+END_SRC

** utf-8 კოდირება და კოდირების მეთოდები 

ელექტრონულად ინფორმაციის გადაცემა/დამახსოვრება უნიკოდის შესაბამისი რიცხვების სახით ძალზედ არაეფექტურია.
წარმოვიდგინოთ რომ გვინდა გადავცეთ ქართული ანბანის სიმბოლოები ა,ბ,გ,დ, რის შესაბამისი ორობითი ექვივალენტი იქნება 

#+BEGIN_SRC bash
4302 - 0b1000011001110
4303 - 0b1000011001111
4304 - 0b1000011010000
4305 - 0b1000011010001
#+END_SRC

ბინარული კოდიდან კარგად ჩანს რომ ზედა მინიმუმ 7 ბიტი გამოუყენებელია და ტყუილად გადავცემთ, თან ვიკავებთ კომუნიკაციის არხს.
სწორედ იმისთვის, რომ არ მოდეს ზედმეტი ინფორმაციის გადაცემა, გამოიყენება კოდირების სისტემები როგორიცაა utf-8, utf-16 cp-1252
და ა.შ. 
კოდირების სისტემებიდან ყველაზე მეტად გავრცელებულია და უკვე ფაქტიურად  საყოველთაო სტანდარტია UTF-8 კოდირება. 
გავიხოლოთ თუ რას წარმოადგენს utf-8:

|  ბაიტების |      საინფორმაციო |          |          |          |          |
| რაოდენობა | ბიტების რაოდენობა |  I ბაიტი | II ბაიტი | III ბაიტი | IV ბაიტი |
|-----------+-------------------+----------+----------+----------+----------|
|         1 |                 7 | 0xxxxxxx |          |          |          |
|         2 |                11 | 110xxxxx | 10xxxxxx |          |          |
|         3 |                16 | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
|         4 |                21 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |


ცხრილიდან კრაგად ჩანს კოდირების პრინციპი. იმ შემთხვევაში თუ გვინდა გადავცეთ მხოლოდ 0 დან 127-მდე რიცხვი, საკმარისია
მხოლოდ პირდაპირ რიცხვის გადაცემა, დეკოდირებისას თუ ბაიტიდ უმაღლესი ბიტი 0-ის ტოლია, მაშინ მოცემული იფორმაციის ნაკადი მხოლოდ ერთ
ბაიტიანია და რიცხვიც ქვედა ბიტების შესაბამისია. თუ გვინდა გადავცეთ მაქსიმუმ 11 ბიტი მაშინ პირველი სამ ბიტში 110 აღნიშნავს, რომ
სტრიმი ორ ბაიტიანია და მიღებული ბაიტის გაგრძელებაა კიდევ ერთი ბაიტი. ყოველი შემდგომი დამატებითი ბაიტი შეგვიძლია ამივიცნოთ პირველი ორი
მაღალი თანრიგის რიცხვით, რომელიც უნდა უდრიდეს 10-ს. შესაბამისად 3 ბაიტის გადაცემის შემთხვევაში პირველი ბაიტი დაიწყება 1110-ით.
ხოლო შემდგომი ბაიტები იგივე პრინციპით გადაიცემა, როგორც წინა შემთხვევაში.

მოვახდინოთ ინგლისური სიტყვა "hello"-ს  და ქართული სიტყვა "გამარჯობა"-ს კოდირება ""utf-8"-ში და ვნახოთ რა რაოდენობის ბაიტებად
გარდაიქმნება თითოეული მათგანი.  


#+BEGIN_SRC bash
>>> e = 'hello'
>>> c = e.encode('utf-8')
>>> len(c)
5
>>> 
#+END_SRC

როგორც გამოჩნდა, ინგლისური სიტყვა დაიკავებს მხოლოდ 5 ბაიტს

მინიმუმი რიცხვი რაც ქართულ ასოებს შეესაბამება უნიკოდის მიხედვით არის 4304, ვთქვად ავდექით და შევინახეთ პირდაპირ მეხსიერებაში,
მაშინ თითოეულ ასოს დასჭირდება 4304/256 დაახლოვებით 17 ბაიტი ადგილი, სულ 17 * 9(ასოების რაოდენობა "გამარჯობა"-ში)
გამოვიდა 153 ბაიტი.

მოვახდინოთ სიტყვა "გამარჯობა"-ის კოდირება 'utf-8' მეთოდით  ბაიტკოდში და ვნახოთ რამდენი ბაიტი გამოვა.

#+BEGIN_SRC bash
>>> g = 'გამარჯობა'
>>> c = g.encode('utf-8')
>>> len(c)
27
>>> 
#+END_SRC

გამოვიდა სულ 27 ბაიტი. აქედან უკვე გასაგებია ' utf-8'-ით კოდირებით რამდენათ ხდება რესურსების ოპტიმიზირება, შენახვის თუ გადაცემის დღოს 

** ბაიტსტრინგი 
როგორც ვიცით, პითონში სტრინგი წარმოდგენილია უნიკოდის სახით (იგულისხმება python3, python2 -ში ჩვეულებრივ სტრინგი წარმოდგენილია 
ბაიტსტრინგის სახით). გარდა სტრინგისა არსებობს დამატებით სტრინგის მსგავსი ტიპი ბაიტსტრინგი. ბაიტსტრინგის თითოეული წევრის მაქსიმალური სიდიდე 255 ბიტია.
მაგალითად b'hello, world' მსგავსი ჩანაწერი წარმოადგენს ბაიტსტრინგს.  
აუცილებელია დავიმახსოვროთ რომ ბაიტსტრინგი სტრინგი არ არის, ამიტომ ჩანაწერი

#+BEGIN_SRC bash
>>> bs = b'something'
>>> newb = bs+'just string'
ყოველთვის აღძრავს შემდეგ ერორს
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't concat bytes to str
#+END_SRC

სტრინგის ბაიტსტრინგთან შეერთება შესაძლებელია მხოლოდ, ბაიტსტრინგის სტრინგად ან სტრინგის ბაიტსტრინგად გარდაქმნის შემდეგ
მაგალითად, ბაიტსტრინგის გარდაქმნა სტრინგად შესაძლებელია შემდეგნაირად:

>>> st = bs.decode('utf-8') 

ბაიტსტრიგის სტრინგად გარდაქმნის შემდეგ, უპრობლემოდ შეგვიძლია კონკატენაცია (სტრინგების გაერთიანება)

#+BEGIN_SRC bash
>>> st + ' just string' 
'something just string'
#+END_SRC
ხოლო სტრინგის გარდაქმნა ბაიტსტრინგად ხდება შემდეგნაირად

>>> st = 'some string'.encode('utf-8') 


** სტრინგზე მოქმედებები

*** string and escape sequence

სტრინგის გამოყენების დროს საჭიროა გვქონდეს წარმოდგენა ე.წ. "Escape sequence" მეთოდებზე.
ქვემოთ მოცემულია "Escape sequence"-სების ჩამონათვალი.
. \' --- single-quote     # დავბეჭდავთ ' ჩარაქტერს შედეგანირად print('\'')
. \" --- double-quote     # დავბეჭდავთ " ჩარაქტერს შედეგანირად print('\"')
. \\ --- backslash        # დავბეჭდავთ \ ჩარაქტერს შედეგანირად print('\\')
. \a --- bell	          # ხმოვანი სიგნალის გამოძახება print('\a')
. \b --- backspace        # წინმდგომი სიმბოლოს წაშლა print('hi\bello') დაბეჭდავს hello-ს
. \f --- formfeed         # მოცემული მოქმედება, გარკვეული მანძილით დააშორებს სტრინგის ნაწილებს მაგ. print('hello,\tworld') დაბეჭდავს "hello,	world"-ს 
. \n --- newline	  # ახალ ხაზზე გადასვლა, მაგალითად print('\n\n\nHello')  სამჯერ გადავა ახალ ხაზზე და შემდეგ დაწერს Hello-ს 
. \r --- carriage return  # გადაიტანს კურსორს ტერმინალის მარცხენა კიდეში. print('hello, \rworld') დაბეჭდავს "world,"-ს
. \t --- tab	          # ტაბი
. \v --- vertical tab     # გააკეთებს ვერტიკალურ ტაბს 


*** სტრინგის ფორმატირება
print ფუნქციის გამოყენებისას, ხშირად საჭიროა კონკრეტული ცვლადების ჩასმა შესაბამის ადგილას
მაგალითად

#+BEGIN_SRC bash
saxeli = 'ჯონ' 
gvari = 'დო'
asaki = 25
print('სახელი: '+ saxeli + ', გვარი: '+ gvari + ", ასაკი: "+ str(asaki))
#+END_SRC

ერთი შეხედვითაც კარგად ჩანს რომ მსგავსი ჩანაწერი არც ისე მოხერხებულია, მოქმედება გაცილებით მოხერხებულად დაიწერება
format ფუნქციით მაგალითად:

print('სახელი: {}, გვარი: {}, ასაკი:{}'.format(saxeli, gvari, asaki))

ასევე შესაძლებელია როგორც C პროგრამირების ენაში შემდეგნაირად დავწეროთ (არც ისე მოხერხებულია format ფუნქციასთან შედარებით)

print('სახელი: %s, გვარი: %s, ასაკი: %s'%(saxeli, gvari, asaki))
   
*** სტრინგის დაჭრა (slicing)

პითონში სტრინგი წარმოადგენს უნიკოდის შესაბამისი ობიექტების კოლექციას. ისევე როგორც ნებისმიერ კოლექციას ასევე სტრინგის 
ელემენტებსაც აქვს ინდექსი. ქვემოთ მოცემულ ცხრილზე ჩანს სტრინგის (კონკრეტულად 'Hello, world!'-ის) ინდექსაციის მექანიზმი.

*ინდექსაცია პირდაპირი მიმართულებით*

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|---+---+---+---+---+---+---+---+---+---+----+----+----|
| H | e | l | l | o | , |   | w | o | r |  l |  d |  ! |

*ინდექსაცია უკუ მიმართულებით*

| -13 | -12 | -11 | -10 | -9 | -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 |
|-----+-----+-----+-----+----+----+----+----+----+----+----+----+----|
|   H |   e |   l |   l |  o |  , |    |  w |  o |  r |  l |  d |  ! |


პითონში ინდექსაცია იწყება ყოველთვის 0 ინდექსიდან. მაგალითად თუ გვინდა ავიღოთ პირველი ელემენტი სტრინგიდან:

#+BEGIN_SRC bash
>>>s = 'Hello, world!'
>>>print(s[0])
H
>>>print(s[-1])
!
#+END_SRC

*** string slicing
ინდექსების მეშვობოთ, შეგვიძლია ავიღოთ რაიმე ადგილი სტრინგიდან მაგალითად:

#+BEGIN_SRC bash
>>>s = 'Hello, world!'
>>>print(s[0:6])
Hello
თუ გვიდა, რომ დასაწყისიდანვე ამოიღოს
>>>s = 'Hello, world!'
>>>print(s[:6])
Hello
ან პირიქით, მაგ. -6 ინდექსიდან ბოლომდე
>>>s = 'Hello, world!'
>>>print(s[-6:])
world!
#+END_SRC

ასევე შესაძლებელია ბიჯის მითითება და იმ თანმიმდევრობით სტრინგის ამოღება მაგ:
#+BEGIN_SRC bash
>>> s = 'Hello, world!'
>>> s[0:-1:2]
'Hlo ol'
#+END_SRC

სადაც 0:-1 ნიშნავს, რომ სტრინგი აღებულია 0 დან -1-მდე (ანუ ბოლოს წინა რიცხვამდე), ხოლო 2 ბიჯია
   
მსგავსი პრინციპით შესაძლებელია სტრინგის რევერსიაც მაგ:
#+BEGIN_SRC bash
>>> s = 'Hello, world!'
>>> 
>>> s[::-1]
'!dlrow ,olleH'
>>> 
#+END_SRC


*** სტრინგის მეთოდები
სტრინგს როგორც ტიპს აქვს სხვადასხვა მეთოდები, განვიხილოთ რამოდენიმე მათგანი

split მეთოდს შეუძლია დაანაწევროს სტრინგი რომელიმე ელემენტის მიხედვით მაგ:

დაანაწევრება გამოტოვებული ადგილის მიხედვით
#+BEGIN_SRC bash
>>>s = 'Hello, world!'
>>>s.split()
['Hello,', 'world!']

#დაანაწევრება 'o' სტრინგის მიხედვით
>>>s.split('o')
['Hell', ', w', 'rld!']
#+END_SRC

lower და upper მეთოდები სტრინგის წევრებს გადააქცევენ პატარა და დიდ სიმბოლოებად მაგ:
#+BEGIN_SRC bash
>>> s = 'Hello, world!'
>>> s.lower()
'hello, world!'
>>> s.upper()
'HELLO, WORLD!'
#+END_SRC

count დაითვლის თუ რამდენჯერ შეიცავს რომელიმე სტრინგს სტრინგი მაგ:
#+BEGIN_SRC bash
>>> s = 'Hello, world!'
>>> s.count('l')
3
>>> s.count('wo')
1
>>> 
#+END_SRC


find მეთოდი მოძებნის და დააბრუნებს პირველივე ნაპოვნი ელემენტის ინდექსს მაგ:
#+BEGIN_SRC bash
>>> s = 'Hello, world!'
>>> s.find('o')
4
>>> 
#+END_SRC

join ფუნქცია გააერთიანებს სტრინგების კოლექციას ერთ სტრინგად მაგ:
#+BEGIN_SRC bash
>>> '+'.join(['1','2','3','4'])
'1+2+3+4'
#+END_SRC

strip ფუნქცია მოჭრის სტრინგის თავში და ბოლოში მითითებულ ელემენტებს მაგ:
#+BEGIN_SRC bash
>>> s = ' Hello, world!  '
>>> print(s)
 Hello, world!  
>>> s.strip()
'Hello, world!'
>>> 
>>> s = 'Hello, world!'
>>> s.strip('!')
'Hello, world'
#+END_SRC

