* კოდირების მეთოდები და სტრინგზე მოქმედებები

** უნიკოდი 
60 - წლებიდან ამერიკაში არსებობდა [[https://en.wikipedia.org/wiki/ASCII][ASCII]] (American Standard Code for Information Interchange) სიმბოლოების სტანდარტიზაციის მეთოდი, რომელსაც იყენებდნენ ტელეტაიპით 
ტექსტის გადაცემის დროს. ASCII-ში მოცემულია ინგლისური ანბანის დიდი და პატარა ასოები, ასევე 0-დან 9-მდე რიცხვები და დამატებითი სიმბოლოები როგორიცაა . , : ; []{} და ა.შ.
ისევე როგორც ამერიკაში, სხვა ქვეყნებშიც დაიწყეს ინფორმაციის მიმოცვლის საკუთარი სტანდარტების დამუშავება. მაგალითად იაპონიაში არსებობდა რამოდენიმე სტანდარტი და თვითონ 
იაპონირ კომპანიებს შორის ტექსტის ერთმანეთში დაგადზავნისას იქმნებოდა პრობლემები, სხვა რომ არღარაფერი ვთქვათ სხვა ქვეყანაში ტექსტის გაგზავნაზე. ინტერნეტის შექმნის 
მომენტში, 80 წლების ბოლოს გაჩნდა საერთაშორისო სტანდარტის შექმნის მოთხოვნა. ამის გამო 1991  წელს შიექმნა Unicode კონსორციუმი. რომლის მიზანი იყო შეექმნა ტექსტური 
ინფორმაციის კოდირების საერთაშორისო სტანდარტი. დღეისთვის უნიკოდი შეიცავს 128000 სიმბოლოს, თითქმის ნებისმიერ სიმბოლოს რაც კაცობრიობის ისტორისს მანძილზე არსებობდა და 
ცნობილია. 
სულ რამოდენიმე სიტყვით, უნიკოდი ეს არის მსოფლიოში არსებული ყველა ხელნაწერი სიმბოლოს (და არა მარტო) უნიფიცირების მეთოდი.
უნიკოდში ყოველ ხელნაწერის ელემენტს მინიჭებული აქვს გარკვეული რიგითი ნომერი. მაგალითად არაბული რიხვითი სიმბოლოები და ინგლისური 
ანბანის პირველი ასოები მოთავსებული უნიკოდის 128 მდე რიგში, ქართული 4304-დან 4337-მდე შუალედში, ჩინური ძირითადი 19968-დან 40959-მდე შუალედში, და ა.შ

მაგ:
0 - 48
1 - 49
2 - 50
. . .
9 - 57
. . .
A - 65
B - 66 
.
Z - 90
.
a - 97
b - 98
.
z - 122
. . .
ა - 4304
ბ - 4305
. . .
ჰ - 4336
. . .

** utf-8 კოდირება და კოდირების მეთოდები 
2. კოდირების მეთოდები utf-8 (CP-1252)
იმისთვის რომ გადავცეთ რაიმე ინფორმაცია ელექტრონულად პირდაპირ უნიკოდის შესაბამისი რიხვების სახით, ძალიან არაეფექტურია.
წარმოვიდგინოთ რომ გვინდა გადავცეთ ქართული ანბანის სიმბოლოები ა,ბ,გ,დ, რის შესაბამისი ორიბითი ექვივალენტი იქნება 

4302 - 0b1000011001110
4303 - 0b1000011001111
4304 - 0b1000011010000
4305 - 0b1000011010001
ბინარული კოდიდან კარგად ჩანს რომ ზედა ნინიმუმ 7 ბიტი გამოუყენებელია და ყუილად გადავცემთ და ვიკავებთ კომუნიკაციის არხს.
სწორედ იმისთვის, რომ არ მოდეს ზედმეტი ინფორმაციის გადაცემა, გამოიყენება კოდირების სისტემები როგორიცაა utf-8, utf-16 cp-1252
და ა.შ. 
კოდირების სისტემებიდან ყველაზე მეტად გავრცელებულია და უკვე ფაქტიურად დაფაულთ სტანდარტია UTF-8 კოდირება. 
გავიხოლოთ თუ რას წარმოადგენს utf-8:

|  ბაიტების |      საინფორმაციო |          |          |          |          |
| რაოდენობა | ბიტების რაოდენობა |  I ბაიტი | II ბაიტი | II ბაიტი | IV ბაიტი |
|-----------+-------------------+----------+----------+----------+----------|
|         1 |                 7 | 0xxxxxxx |          |          |          |
|         2 |                11 | 110xxxxx | 10xxxxxx |          |          |
|         3 |                16 | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
|         4 |                21 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |


ცხრილიდან კრაგად ჩანს კოდირების პრინციპი. იმ შემთხვევაში თუ გვინდა გადავცეთ მხოლოდ 0 დან 127-მდე რიცხვი, საკმარისია
მხოლოდ პირდაპირ რიცხვის გადავემა, დეკოდირებისას თუ ბაიტიდ უმაღლესი ბიტი 0-ის ტოლია, მაშინ მოდემულია იფორმაციის ნაკადი მხოლოდ ერთ
ბაიტიანია და რიცხვიც შესაბამისი ქვედა ბიტების შესაბამისია. თუ გვინდა გადავცეთ მაქსიმუმ 11 ბიტი მაშინ პირველი სამ ბიტში 110 აღნიშნავს,
სტრიმი ორ ბაიტიანია და მიღებული ბაიტის გაგზელებაა კიდევ ერთი ბაიტი. ყოველი შემდგომი დამატებითი ბაიტი შეგვიძლია ამივიცნოთ პირველი ორი
მაღალი თანრიგის რიცხვით, რომელიც უნდა უდრიდეს 10-ს. შესაბამისად გრძელდაბა 3 ბაიტის გადაცემის შემთხვევაში პირველი ბაიტი დაიწყება 1110-ით.
ხოლო შემდგომი ბაიტები იგივე პრინციპით გადაიცემა, როგორც წინა შემთხვევაში.

მოვახდინოთ სიტყვა ინგლისური სიტყვა "hello"-ს  და ქართული სიტყვა "გამარჯობა"-ს კოდირება ""utf-8"-ში და ვნახოთ რა რაოდენობის ბაიტებად
გარდაიქმნება თითოეული მათგანი.  
ინგლისური სიტყვა დაიკავებს მხოლოდ 5 ბაიტს, მინიმუმი რიცხვი რაც ქართულ ასოებს შეესაბამება არის 4304, ეს გავამრავლოთ ასოების რაოდენობაზე
4304*9 = 38736, ვთქვად ავდექით და შევინახეთ პირდაპირ მეხსიერებაში მაშინ თითოეულ ასოს დასჭირდება 4304/8 -- 17 ბაიტი ადგილი
სულ გამოდის 153 ბაიტი.
ეხლა გავაკეთოთ შემდეგი: 'utf-8' კოდირებით გადავიყვანოთ  "გამარჯობა" ბაიტკოდში და ვნახოთ რამდენი ბაიტი გამოვა.

>>> g = 'გამარჯობა'
>>> c = g.encode('utf-8')
>>> len(c)
27
>>> 
გამოვიდა სულ 27 ბაიტი. აქედან უკვე გასაგებია ' utf-8'-ით კოდირებით რამდენათ ხდება რესურსების ოპტიმიზირება, შენახვის თუ გადაცემის დღოს 


3. ბაიტსტრინგი 
როგორც ვიცით, პითონში სტრინგი წარმოდგენილია უნიკოდის სახით (იგულისხმება python3, python2 -ში ჩვეულებრივ სტრინგი წარმოდგენილია 
ბაიტსტრინგის სახით). გარდა სტრინგისა არსებობს დამატებით ბაიტსტრინგი, ბაიტსტრინგის თითოეული წევრის მაქსიმალური სიდიდე 255 ბიტია.
მაგალითად b'hello, world' მსგავსი ჩანაწერი წარმოადგენს ბაიტსტრინგს.  
აუცილებელია დავიმახსოვროთ რომ ბაიტსტრინგი სტრინგი არ არის ამირომ ჩანაწერი
>>> bs = b'something'
>>> newb = bs+'just string'
ყოველთვის აღძრავს შემდეგ ერორს
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't concat bytes to str

სტრინგის ბაიტსტრინგთან შეერთება შესაძლებელია მხოლოდ, ბაიტსტრინგის სტრინგად ან სტრინგის ბაიტსტრინგად გარდაქმნის შემდეგ
მაგალითად, ბაიტსტრინგის გარდაქმნა სტრინგად შესაძლებელია შემდეგნაირად:
>>> st = bs.decode('utf-8') 
ბაიტსტრიგის სტრინგად გარდაქმნის შემდეგ, უპრობლემოდ შეგვიძლია კონკატენაცია (სტრინგების გაერთიანება)
>>> st + ' just string' 
'something just string'
ხოლო სტრინგის გარდაქმნა ბაიტსტრინგად ხდება შემდეგნაირად
>>> st = 'some string'.encode('utf-8') 


5. string and escape sequence
სტრინგის გამოყენების დროს საჭიროა გვქონდეს წარმოდგენა ე.წ. "Escape sequence" მეთოდებზე.
ქვემოთ მოცემულია "Escape sequence"-სების ჩამონათვალი.
\' --- single-quote     # დავბეჭდავთ ' ჩარაქტერს შედეგანირად print('\'')
\" --- double-quote     # დავბეჭდავთ " ჩარაქტერს შედეგანირად print('\"')
\\ --- backslash        # დავბეჭდავთ \ ჩარაქტერს შედეგანირად print('\\')
\a --- bell	        # ხმოვანი სიგნალის გამოძახება print('\a')
\b --- backspace        # წინმდგომი სიმბოლოს წაშლა print('hi\bello') დაბეჭდავს hello-ს
\f --- formfeed         # მოცემული მოქმედება, გარკვეული მანძილით დააშორებს სტრინგის ნაწილებს მაგ. print('hello,\tworld') დაბეჭდავს "hello,	world"-ს 
\n --- newline	        # ახალ ხაზზე გადასვლა, მაგალითად print('\n\n\nHello')  საჯერ გადავა ახალ ხაზზე და შემდეგ დაწერს Hello-ს 
\r --- carriage return  # გადაიტანს კირსორს ტერმინალის მარცხენა კიდეში. print('hello, \rworld') დაბეჭდავს "world,"-ს
\t --- tab	        # ტაბი
\v --- vertical tab     # გააკეთებს ვერტიკალურ ტაბს 


6. სტრინგის ფორმატირება
print ფუნქციის გამოყენებისას, ხშირად საჭიროა კონკრეტული ცვლადების ჩასმა შესაბამის ადგილას
მაგალითად
saxeli = 'ჯონ' 
gvari = 'დო'
asaki = 25
print('სახელი: '+ saxeli + ', გვარი: '+ gvari + ", ასაკი: "+ str(asaki))
ერთი შეხედვითაც კარგად ჩანს რომ მსგავსი ჩანაწერი არც ისე მოხერხებულია, მსგავსი მოქმედება გაცილებით მოხერხებულად დაიწერება
format ფუნქციით მაგალითად:
print('სახელი: {}, გვარი: {}, ასაკი:{}'.format(saxeli, gvari, asaki))
ასევე შესაძლებელია როგორც C პროგრამირების ენაში შემდეგნაირად დავწეროთ (არც ისე მოხერხებულია format ფუნქციასთან შედარებით)
print('სახელი: %s, გვარი: %s, ასაკი: %s'%(saxeli, gvari, asaki))
   
7. სტრინგის დაჭრა (slicing)



8. სტრინგის ფუნქციები


