*დეკორატორები*

* შესავალი, დეკორატორის გამოყენების მაგალითები 
Python-ზე პროგრამირებისას "დეკორატორის" სინტაქსი არის ერთ-ერთი უმნიშნელო 
(რადგან სინამდვილეში არაფერია, სისტაქსის მარილის გარდა) და ასევე მნიშვნელოვანი 
(თუნდაც იმიტომ რომ ხშირად გხვდება სხვადასხვა ფრეიმვორკებში). 
დეკორატორის გაგონებისთანავე უმრავლესობას უჩნდება მისი პროგრამის დიზაინთან კავშირის ასოციაცია. 
მაგრამ სინამდვილეში დეკორატორს დიზაინთან არანაირი კვშირი არ აქვს, თუ რა თქმა უნდა შეგნებულად 
არ გამოვიყენეთ ის დიზაინისთვის.

პირველ რიგში მოვიყვანოთ დეკორატორის გამოყენების რამოდენიმე მაგალითი

მაგ. I

ვებ სერვერის ფუნქცია რომელიც აბრუნებს html გვერდს (ფაილს) შესაბამის მისამართზე მიმართვისას.
როგორც ხედავთ ქვემოთ მოცემულია ორი ფუნქცია პირველი გამოიძახება საიტის მაგ http://www.simplesite.com/ - ზე 
მიმართვისას ხოლო მეორე http://www.simplesite.com/login - ის დროს.

#+BEGIN_SRC python
@route('/')
def main():
    return "<h1>Hello, web</h1>"

@route('/login')
def login():
    return "<h1>This is login page</h1>"
#+END_SRC
=მაგალითი მოყვანილია= [[http://bottlepy.org/docs/dev/][bottle]] =ფრეიმვორკიდან=

როგოც მაგალითიდან ჩანს, დეკორატორი იწერება ფუნქციის თავზე @-ის და დეკორატორის დასახელებით.
ჩვენს შემთხვევაში თითოეულ ფუნქციას თავზე ეწერება route დეკორატორი, რომელიც აიღებს მოცემულ main და login ფუნქციებს 
და მიაბავს მათ კონკრეტულ მისამრთზე მიმართვის ფუნქციას (http get, set და ა.შ.).

განვიხილოთ მეორე მაგალითი, რომელშიც დეკორატორის დახმარებით ფუნქცია სრუნლდება ასინქრონულად (დამოუკიდებლად).
მაგ. II

#+BEGIN_SRC python 
import time
from SimpleThread import Thread

@Thread()
def funct1():
    while True:
        time.sleep(1)
        print('hello from funct1')
    
@Thread()
def funct2():
    while True:
        time.sleep(1)
        print('hello from funct2')

while True:
    time.sleep(1)
        
#+END_SRC

შედეგად ტერმინალში მუდმივად დაწერს ორივე ფუნქციის შესრულების შედეგს მაგ.
 
#+BEGIN_SRC bash
hello from funct1
hello from funct2
hello from funct1
hello from funct2
#+END_SRC

[[https://gist.github.com/SaturnR/909a63e471cd85dd69fa2cd2452f65f6][SimpleThread]] მოდული შეიცავს Thread დეკორატორს, რომელიც აიღებს თითოეულ ფუნქციას და გადაიტანს ასინქრონულ 
ნაკადში, ანუ ორივე ფუნქციის შიგნით მულმივი ციკლი იმუშავებს მუდმუვად ერთმანეთისაგან დამოუკიდებლად. 

* განვიხილოთ დეკორატორის რამოდენიმე მარტივი შემთხვევა 

** დეკორატორი როგორც ფუნქცია

დეკორატორი მარტივად შეგვიძლია წარმოვადგინოთ როგორც ფუნქცია, რომელიც პარამეტრის სახით იღებს მეორე ფუნქციას.
ქვემოთ მოცემულია დეკორატორის მაგალითი, რომელიც ამოწმებს გაიარა თუ არა ავტორიზაცია მომხხმარებლმა,
ფუნქციაზე მიმართვის წინ, თუ არ გაუვლია, გადაამისამართებს გვედზე, სადაც იქნება წარწერა, 
"გთხოვთ გაიაროთ ავტორიაცია".

#+BEGIN_SRC python
def checkLogin(func):
    def inner(*args, **kwargs):
        login = checklogin()
        if not login:
            return redirect('/login_error')
        result = func(*args, **kwargs)
    return result
#+END_SRC

მოცემული დეკორატორის გამოყენება შეგვიძლია ზემოთ აღწერილი მაგალითების მსგავსად
მაგ. 
#+BEGIN_SRC python
@checkLogin()
def main():
    return '<h1>This is a main page</h1>'
#+END_SRC

როგორც ვიცით პითონში ყველაფერი ობიექტია, მათ შორის ფუნქციაც. აქედან გამომდინარე, 
ფუნქციის დასახელებას შეგვიძლია მოვექცეთ როგორც ობიექტს, ანუ გადავცეთ მეორე ფუნქციას პარამეტრის სახით ან
შევქმნათ დინამიურად. სწორედ პითონის ეს დინამიურობის თვისება წარმოადგენს დეკორატორის საფუძველს.

განვიხილოთ კიდევ ერთი მაგალითი, დავწეროთ დეკორატორი, რომელიც შეამოწმებს თუ რა დრო სჭირდება ამა თუ იმ ფუნქციას 
რაიმე ამოცანის შესასრულებლად.

#+BEGIN_SRC python
import time

def perform(func):
    def inner(*argv, **kwargv):        
        stime = time.time()
        fpar = func(*argv, **kwargv)
        dtime = time.time() - stime
        print('time passed: ', dtime)
        return fpar
    return inner

@perform
def factorial(maximal):
    m = 1
    for n in range(1,maximal):
        m *= n
    return m


for n in range(3):
    result = factorial(10**n)
    print(result)
        
#+END_SRC

მთელი ეს ჯადოქრობა შეგვეძლო დაგვეწერა დეკორატორის სინტაქსის (@perform) გარეშეც, ასე მაგ.
#+BEGIN_SRC python
factorial = perform(factorial)
#+END_SRC 
აქედან ხცადად ჩანს, რომ დეკორატორის სინტაქსი გაცილებით მოსახერხებელია 
  

** დეკორატორი როგორც კლასი 

   დეკორატორი ყველაზე ცხადად განისაზღვრება კლასების გამოყენებით, კონკრეტულად კლასის ე.წ. "magic" __call__
ფუნქციის გამოყენებით. მაგ.

*** უარგუმენტო დეკორატორი 

#+BEGIN_SRC python

import time
# PythonDecorators/my_decorator.py
class TimeDelta(object):

    def __init__(self, f):
        self.f = f
        
    def __call__(self, *argv, **kwargv):
        print('Power of {} by {}'.format(argv[0], argv[1]))
        # მსგავსი მეთოდით შეგვიძლია გამოვიყენოთ ფუნქციისთვის გადაცემული ატრიბუტები
        stime = time.time()
        fpar = self.f(*argv, **kwargv)
        dtime = time.time() - stime
        print(' Time passed: ', dtime)
        return fpar #  დავაბრუნოთ შესრულებული ფუნქციის მნიშვნელობა

@TimeDelta
def Power(a, n):
    return a**n


a = Power(3, 4)
print(a)

#+END_SRC 

როგორც ხედავთ, დეკორირებადი ფუნქცია გადაეცემა __init__ კონსტრუქტორ ფუნქციას, პირველი არგუმენტის შემდეგ
(პირველი არგუმენტი თვით კლასის ობიექტია). ხოლო დეკორირებადი ფუნქცია ჩანაცვლდება __call__ ფუნქციით. 
ასევე დეკორირებადი ფუნქციისთვის გადაცემული არგუმენტები, გადაეცემა __call__ ფუნქციას. იმისთვის, 
რომ შესაძლებელი იყოს, რაოდენობისა და ტიპის გარეშე მივიღოთ ყველანაირი არგუმენტი, ვიყენებთ არგუმენტების 
არაცხად განსაზღვრას. პირველ შემთვევაში ეს არის *argv იმისთვის რომ მივიღოთ ნებისმიერი რაოდებობის არგუმენტი, 
ხოლო მეორე შემთხვევაში **kwargv, რომ მივიღოთ ნებისმიერი რაოდენობის სახელდებული არგუმენტები მაგ.  
name = 'ჯონდო'. 
როგორც ზემოთ აღწერილი მაგალითიდან ჩანს, დეკორატორის მგავსი სახით ჩაწერა გაცილებით მოსახერხებელია.

*** დეკორატორი არგუმენტებით

არგუმენტებიანი დეკორატორის შემთხვევაში მდგომარეობა მნიშვნელოვნად განსხავებულია. ამ შემთხვევაში დეკორირებული 
ფუნქცია აღარ გადაეცემა ე.წ. კონსტრუქტორ __init__ მეთოდს, არამედ გადაეცემა __call__ მეთოდს არგუმენტის სახით.
ხოლო __call__ მეთოდი სრულდება მხოლოდ ერთხელ დეკორირების პროცესში და პარამეტრად გადაცემულ f ფუნქციას 
ანაცვლებს inner ფუნქციით. როგორც ხედავთ __call__ ფუნქციით დეკორირების პრინციპი, ზემოთ განხილული ფუნქცია 
დეკორატორის მსგავსია.

#+BEGIN_SRC python
import time
# PythonDecorators/my_decorator.py
class TimeDelta(object):

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
        print(self.a, self.b, self.c)
        
    def __call__(self, f):

        def closure(*argv, **kwargv):
            print('Power of {} by {}'.format(argv[0], argv[1]))
            # მსგავსი მეთოდით შეგვიძლია გამოვიყენოთ ფუნქციისთვის გადაცემული ატრიბუტები
            stime = time.time()
            fpar = f(*argv, **kwargv)
            dtime = time.time() - stime
            print(' Time passed: ', dtime)
            return fpar #  დავაბრუნოთ შესრულებული ფუნქციის მნიშვენლობა
        return closure

@TimeDelta(1,2,3)
def Power(a, n):
    return a**n

a = Power(3, 4)
print(a)
#+END_SRC 


დამატებითი ინფორმაციისთვის

http://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html
