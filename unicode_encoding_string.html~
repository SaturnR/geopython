<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>unicode_encoding_string</title>
<!-- 2016-12-01 Thu 15:29 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="saturn" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">unicode_encoding_string</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. კოდირების მეთოდები და სტრინგზე მოქმედებები</a>
<ul>
<li><a href="#sec-1-1">1.1. უნიკოდი</a></li>
<li><a href="#sec-1-2">1.2. utf-8 კოდირება და კოდირების მეთოდები</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. string slicing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> კოდირების მეთოდები და სტრინგზე მოქმედებები</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> უნიკოდი</h3>
<div class="outline-text-3" id="text-1-1">
<p>
60 - წლებიდან ამერიკაში არსებობდა <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> (American Standard Code for Information Interchange) სიმბოლოების სტანდარტიზაციის მეთოდი, რომელსაც იყენებდნენ ტელეტაიპით 
ტექსტის გადაცემის დროს. ASCII-ში მოცემულია ინგლისური ანბანის დიდი და პატარა ასოები, ასევე 0-დან 9-მდე რიცხვები და დამატებითი სიმბოლოები როგორიცაა . , : ; []{} და ა.შ.
ისევე როგორც ამერიკაში, სხვა ქვეყნებშიც დაიწყეს ინფორმაციის მიმოცვლის საკუთარი სტანდარტების დამუშავება. მაგალითად იაპონიაში არსებობდა რამოდენიმე სტანდარტი და თვითონ 
იაპონირ კომპანიებს შორის ტექსტის ერთმანეთში დაგადზავნისას იქმნებოდა პრობლემები, სხვა რომ არღარაფერი ვთქვათ სხვა ქვეყანაში ტექსტის გაგზავნაზე. ინტერნეტის შექმნის 
მომენტში, 80 წლების ბოლოს გაჩნდა საერთაშორისო სტანდარტის შექმნის მოთხოვნა. ამის გამო 1991  წელს შიექმნა Unicode კონსორციუმი. რომლის მიზანი იყო შეექმნა ტექსტური 
ინფორმაციის კოდირების საერთაშორისო სტანდარტი. დღეისთვის უნიკოდი შეიცავს 128000 სიმბოლოს, თითქმის ნებისმიერ სიმბოლოს რაც კაცობრიობის ისტორისს მანძილზე არსებობდა და 
ცნობილია. 
სულ რამოდენიმე სიტყვით, უნიკოდი ეს არის მსოფლიოში არსებული ყველა ხელნაწერი სიმბოლოს (და არა მარტო) უნიფიცირების მეთოდი.
უნიკოდში ყოველ ხელნაწერის ელემენტს მინიჭებული აქვს გარკვეული რიგითი ნომერი. მაგალითად არაბული რიხვითი სიმბოლოები და ინგლისური 
ანბანის პირველი ასოები მოთავსებული უნიკოდის 128 მდე რიგში, ქართული 4304-დან 4337-მდე შუალედში, ჩინური ძირითადი 19968-დან 40959-მდე შუალედში, და ა.შ
</p>

<p>
მაგ:
0 - 48
1 - 49
2 - 50
. . .
9 - 57
. . .
A - 65
B - 66 
.
Z - 90
.
a - 97
b - 98
.
z - 122
. . .
ა - 4304
ბ - 4305
. . .
ჰ - 4336
. . .
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> utf-8 კოდირება და კოდირების მეთოდები</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>კოდირების მეთოდები utf-8 (CP-1252)
</li>
</ol>
<p>
იმისთვის რომ გადავცეთ რაიმე ინფორმაცია ელექტრონულად პირდაპირ უნიკოდის შესაბამისი რიხვების სახით, ძალიან არაეფექტურია.
წარმოვიდგინოთ რომ გვინდა გადავცეთ ქართული ანბანის სიმბოლოები ა,ბ,გ,დ, რის შესაბამისი ორიბითი ექვივალენტი იქნება 
</p>

<p>
4302 - 0b1000011001110
4303 - 0b1000011001111
4304 - 0b1000011010000
4305 - 0b1000011010001
ბინარული კოდიდან კარგად ჩანს რომ ზედა ნინიმუმ 7 ბიტი გამოუყენებელია და ყუილად გადავცემთ და ვიკავებთ კომუნიკაციის არხს.
სწორედ იმისთვის, რომ არ მოდეს ზედმეტი ინფორმაციის გადაცემა, გამოიყენება კოდირების სისტემები როგორიცაა utf-8, utf-16 cp-1252
და ა.შ. 
კოდირების სისტემებიდან ყველაზე მეტად გავრცელებულია და უკვე ფაქტიურად დაფაულთ სტანდარტია UTF-8 კოდირება. 
გავიხოლოთ თუ რას წარმოადგენს utf-8:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">ბაიტების</th>
<th scope="col" class="right">საინფორმაციო</th>
<th scope="col" class="right">&#xa0;</th>
<th scope="col" class="right">&#xa0;</th>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="right">რაოდენობა</th>
<th scope="col" class="right">ბიტების რაოდენობა</th>
<th scope="col" class="right">I ბაიტი</th>
<th scope="col" class="right">II ბაიტი</th>
<th scope="col" class="left">II ბაიტი</th>
<th scope="col" class="left">IV ბაიტი</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">7</td>
<td class="right">0xxxxxxx</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">11</td>
<td class="right">110xxxxx</td>
<td class="right">10xxxxxx</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">3</td>
<td class="right">16</td>
<td class="right">1110xxxx</td>
<td class="right">10xxxxxx</td>
<td class="left">10xxxxxx</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">4</td>
<td class="right">21</td>
<td class="right">11110xxx</td>
<td class="right">10xxxxxx</td>
<td class="left">10xxxxxx</td>
<td class="left">10xxxxxx</td>
</tr>
</tbody>
</table>


<p>
ცხრილიდან კრაგად ჩანს კოდირების პრინციპი. იმ შემთხვევაში თუ გვინდა გადავცეთ მხოლოდ 0 დან 127-მდე რიცხვი, საკმარისია
მხოლოდ პირდაპირ რიცხვის გადავემა, დეკოდირებისას თუ ბაიტიდ უმაღლესი ბიტი 0-ის ტოლია, მაშინ მოდემულია იფორმაციის ნაკადი მხოლოდ ერთ
ბაიტიანია და რიცხვიც შესაბამისი ქვედა ბიტების შესაბამისია. თუ გვინდა გადავცეთ მაქსიმუმ 11 ბიტი მაშინ პირველი სამ ბიტში 110 აღნიშნავს,
სტრიმი ორ ბაიტიანია და მიღებული ბაიტის გაგზელებაა კიდევ ერთი ბაიტი. ყოველი შემდგომი დამატებითი ბაიტი შეგვიძლია ამივიცნოთ პირველი ორი
მაღალი თანრიგის რიცხვით, რომელიც უნდა უდრიდეს 10-ს. შესაბამისად გრძელდაბა 3 ბაიტის გადაცემის შემთხვევაში პირველი ბაიტი დაიწყება 1110-ით.
ხოლო შემდგომი ბაიტები იგივე პრინციპით გადაიცემა, როგორც წინა შემთხვევაში.
</p>

<p>
მოვახდინოთ სიტყვა ინგლისური სიტყვა "hello"-ს  და ქართული სიტყვა "გამარჯობა"-ს კოდირება ""utf-8"-ში და ვნახოთ რა რაოდენობის ბაიტებად
გარდაიქმნება თითოეული მათგანი.  
ინგლისური სიტყვა დაიკავებს მხოლოდ 5 ბაიტს, მინიმუმი რიცხვი რაც ქართულ ასოებს შეესაბამება არის 4304, ეს გავამრავლოთ ასოების რაოდენობაზე
4304*9 = 38736, ვთქვად ავდექით და შევინახეთ პირდაპირ მეხსიერებაში მაშინ თითოეულ ასოს დასჭირდება 4304/8 &#x2013; 17 ბაიტი ადგილი
სულ გამოდის 153 ბაიტი.
ეხლა გავაკეთოთ შემდეგი: 'utf-8' კოდირებით გადავიყვანოთ  "გამარჯობა" ბაიტკოდში და ვნახოთ რამდენი ბაიტი გამოვა.
</p>

<p>
&gt;&gt;&gt; g = 'გამარჯობა'
&gt;&gt;&gt; c = g.encode('utf-8')
&gt;&gt;&gt; len(c)
27
&gt;&gt;&gt; 
გამოვიდა სულ 27 ბაიტი. აქედან უკვე გასაგებია ' utf-8'-ით კოდირებით რამდენათ ხდება რესურსების ოპტიმიზირება, შენახვის თუ გადაცემის დღოს 
</p>

<ol class="org-ol">
<li>ბაიტსტრინგი 
</li>
</ol>
<p>
როგორც ვიცით, პითონში სტრინგი წარმოდგენილია უნიკოდის სახით (იგულისხმება python3, python2 -ში ჩვეულებრივ სტრინგი წარმოდგენილია 
ბაიტსტრინგის სახით). გარდა სტრინგისა არსებობს დამატებით ბაიტსტრინგი, ბაიტსტრინგის თითოეული წევრის მაქსიმალური სიდიდე 255 ბიტია.
მაგალითად b'hello, world' მსგავსი ჩანაწერი წარმოადგენს ბაიტსტრინგს.  
აუცილებელია დავიმახსოვროთ რომ ბაიტსტრინგი სტრინგი არ არის ამირომ ჩანაწერი
&gt;&gt;&gt; bs = b'something'
&gt;&gt;&gt; newb = bs+'just string'
ყოველთვის აღძრავს შემდეგ ერორს
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't concat bytes to str
</p>

<p>
სტრინგის ბაიტსტრინგთან შეერთება შესაძლებელია მხოლოდ, ბაიტსტრინგის სტრინგად ან სტრინგის ბაიტსტრინგად გარდაქმნის შემდეგ
მაგალითად, ბაიტსტრინგის გარდაქმნა სტრინგად შესაძლებელია შემდეგნაირად:
&gt;&gt;&gt; st = bs.decode('utf-8') 
ბაიტსტრიგის სტრინგად გარდაქმნის შემდეგ, უპრობლემოდ შეგვიძლია კონკატენაცია (სტრინგების გაერთიანება)
&gt;&gt;&gt; st + ' just string' 
'something just string'
ხოლო სტრინგის გარდაქმნა ბაიტსტრინგად ხდება შემდეგნაირად
&gt;&gt;&gt; st = 'some string'.encode('utf-8') 
</p>


<ol class="org-ol">
<li>string and escape sequence
</li>
</ol>
<p>
სტრინგის გამოყენების დროს საჭიროა გვქონდეს წარმოდგენა ე.წ. "Escape sequence" მეთოდებზე.
ქვემოთ მოცემულია "Escape sequence"-სების ჩამონათვალი.
\' &#x2014; single-quote     # დავბეჭდავთ ' ჩარაქტერს შედეგანირად print('\'')
\" &#x2014; double-quote     # დავბეჭდავთ " ჩარაქტერს შედეგანირად print('\"')
\\ &#x2014; backslash        # დავბეჭდავთ \ ჩარაქტერს შედეგანირად print('\\')
\a &#x2014; bell                # ხმოვანი სიგნალის გამოძახება print('\a')
\b &#x2014; backspace        # წინმდგომი სიმბოლოს წაშლა print('hi\bello') დაბეჭდავს hello-ს
\f &#x2014; formfeed         # მოცემული მოქმედება, გარკვეული მანძილით დააშორებს სტრინგის ნაწილებს მაგ. print('hello,\tworld') დაბეჭდავს "hello,        world"-ს 
\n &#x2014; newline                # ახალ ხაზზე გადასვლა, მაგალითად print('\n\n\nHello')  საჯერ გადავა ახალ ხაზზე და შემდეგ დაწერს Hello-ს 
\r &#x2014; carriage return  # გადაიტანს კირსორს ტერმინალის მარცხენა კიდეში. print('hello, \rworld') დაბეჭდავს "world,"-ს
\t &#x2014; tab                # ტაბი
\v &#x2014; vertical tab     # გააკეთებს ვერტიკალურ ტაბს 
</p>


<ol class="org-ol">
<li>სტრინგის ფორმატირება
</li>
</ol>
<p>
print ფუნქციის გამოყენებისას, ხშირად საჭიროა კონკრეტული ცვლადების ჩასმა შესაბამის ადგილას
მაგალითად
saxeli = 'ჯონ' 
gvari = 'დო'
asaki = 25
print('სახელი: '+ saxeli + ', გვარი: '+ gvari + ", ასაკი: "+ str(asaki))
ერთი შეხედვითაც კარგად ჩანს რომ მსგავსი ჩანაწერი არც ისე მოხერხებულია, მსგავსი მოქმედება გაცილებით მოხერხებულად დაიწერება
format ფუნქციით მაგალითად:
print('სახელი: {}, გვარი: {}, ასაკი:{}'.format(saxeli, gvari, asaki))
ასევე შესაძლებელია როგორც C პროგრამირების ენაში შემდეგნაირად დავწეროთ (არც ისე მოხერხებულია format ფუნქციასთან შედარებით)
print('სახელი: %s, გვარი: %s, ასაკი: %s'%(saxeli, gvari, asaki))
</p>

<ol class="org-ol">
<li>სტრინგის დაჭრა (slicing)
</li>
</ol>

<p>
პითონში სტრინგი წარმოადგენს უნიკოდის შესაბამისი ობიექტების კოლექციას. ისევე როგორც ნებისმიერ კოლექციას ასევე სტრინგის 
ელემენტებსაც აქვს ინდექსი. ქვემოთ მოცემულ ცხრილზე ჩანს სტრინგის (კონკრეტულად 'Hello, world!'-ის) ინდექსაციის მექანიზმი.
</p>

<p>
<b>ინდექსაცია პირდაპირი მიმართულებით</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">0</th>
<th scope="col" class="right">1</th>
<th scope="col" class="right">2</th>
<th scope="col" class="right">3</th>
<th scope="col" class="right">4</th>
<th scope="col" class="right">5</th>
<th scope="col" class="right">6</th>
<th scope="col" class="right">7</th>
<th scope="col" class="right">8</th>
<th scope="col" class="right">9</th>
<th scope="col" class="right">10</th>
<th scope="col" class="right">11</th>
<th scope="col" class="right">12</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">H</td>
<td class="right">e</td>
<td class="right">l</td>
<td class="right">l</td>
<td class="right">o</td>
<td class="right">,</td>
<td class="right">&#xa0;</td>
<td class="right">w</td>
<td class="right">o</td>
<td class="right">r</td>
<td class="right">l</td>
<td class="right">d</td>
<td class="right">!</td>
</tr>
</tbody>
</table>

<p>
<b>ინდექსაცია უკუ მიმართულებით</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">-13</th>
<th scope="col" class="right">-12</th>
<th scope="col" class="right">-11</th>
<th scope="col" class="right">-10</th>
<th scope="col" class="right">-9</th>
<th scope="col" class="right">-8</th>
<th scope="col" class="right">-7</th>
<th scope="col" class="right">-6</th>
<th scope="col" class="right">-5</th>
<th scope="col" class="right">-4</th>
<th scope="col" class="right">-3</th>
<th scope="col" class="right">-2</th>
<th scope="col" class="right">-1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">H</td>
<td class="right">e</td>
<td class="right">l</td>
<td class="right">l</td>
<td class="right">o</td>
<td class="right">,</td>
<td class="right">&#xa0;</td>
<td class="right">w</td>
<td class="right">o</td>
<td class="right">r</td>
<td class="right">l</td>
<td class="right">d</td>
<td class="right">!</td>
</tr>
</tbody>
</table>


<p>
პითონში ინდექსაცია იწყება ყოველთვის 0 ინდექსიდან. მაგალითად თუ გვინდა ავიღოთ პირველი ელემენტი სტრინგიდან:
</p>

<p>
&gt;&gt;&gt;s = 'Hello, world!'
&gt;&gt;&gt;print(s<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>)
H
&gt;&gt;&gt;print(s[-1])
!
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> string slicing</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
ინდექსების საშუალებით შეგვიძლია ავიღოთ რაიმე ადგილი სტრინგიდან მაგალითად:
&gt;&gt;&gt;s = 'Hello, world!'
&gt;&gt;&gt;print(s[0:6])
Hello
თუ გვიდა რომ დასაწყისიდანვე ამოიღოს
&gt;&gt;&gt;s = 'Hello, world!'
&gt;&gt;&gt;print(s[:6])
Hello
ან პირიქით, მაგ. -6 ინდექსიდან ბოლომდე
&gt;&gt;&gt;s = 'Hello, world!'
&gt;&gt;&gt;print(s[-6:])
world!
</p>


<p>
ასევე შესაძლებელია ბიჯის მითითება და იმ ტანმიმდევრობით სტრინგის ამოღება მაგ:
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; s[0:-1:2]
'Hlo ol'
</p>

<p>
სადაც 0:-1 ნიშნავს, რომ სტრინგი აღებულია 0 დან -1-მდე (ანუ ბოლოს წინა რიცხვამდე), ხოლო 2 ბიჯია
</p>

<p>
მსგავსი პრინციპით შესაძლებელია სტრინგის რევერსიაც მაგ:
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; 
&gt;&gt;&gt; s[::-1]
'!dlrow ,olleH'
&gt;&gt;&gt; 
</p>



<ol class="org-ol">
<li>სტრინგის მეთოდები
</li>
</ol>
<p>
სტრინგს როგორც ტიპს აქვს სხვადასხვა მეთოდები, განვიხილოთ რამოდენიმე მათგანი
</p>

<p>
split მეთოდს შეუძლია დაანაწევროს სტრინგი რომელიმე ელემენტის მიხედვით მაგ:
&gt;&gt;&gt;s = 'Hello, world!'
&gt;&gt;&gt;s.split()
['Hello,', 'world!']
დაანაწევრა გამოტოვებული ადგილის მიხედვით
&gt;&gt;&gt;s.split('o')
['Hell', ', w', 'rld!']
დაანაწევრა 'o' სტრინგის მიხედვით
</p>

<p>
lower და upper მეთოდები სტრინგის წევრებს გადააქცევენ პარატა და დიდ სიმბოლოებად მაგ:
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; s.lower()
'hello, world!'
&gt;&gt;&gt; s.upper()
'HELLO, WORLD!'
</p>


<p>
count დაითვლის თუ რამდენჯერ შეიცავს რომელიმე სტრინგს სტრინგი მაგ:
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; s.count('l')
3
&gt;&gt;&gt; s.count('wo')
1
&gt;&gt;&gt; 
</p>


<p>
find მეთოდი მოძებნის და დააბრუნებს პირველივე ნაპოვნი ელემენტის ინდექსს მაგ:
</p>

<p>
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; s.find('o')
4
&gt;&gt;&gt; 
</p>


<p>
join ფუნქცია გააერთიანებს სტრინგების კოლექციას ერთ სტრინგად მაგ
&gt;&gt;&gt; '+'.join(['1','2','3','4'])
'1+2+3+4'
</p>

<p>
strip ფუნქცია მოჭრის სტრინგის თავში და ბოლოში მითითებულ ელემენტებს მაგ:
</p>

<p>
&gt;&gt;&gt; s = ' Hello, world!  '
&gt;&gt;&gt; print(s)
 Hello, world!  
&gt;&gt;&gt; s.strip()
'Hello, world!'
&gt;&gt;&gt; 
&gt;&gt;&gt; s = 'Hello, world!'
&gt;&gt;&gt; s.strip('!')
'Hello, world'
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: saturn</p>
<p class="date">Created: 2016-12-01 Thu 15:29</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
