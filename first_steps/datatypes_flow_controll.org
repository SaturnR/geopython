* მონაცემთა ტიპები მათემატიკური და ლოგიკური ოპერატორები

** მონაცემთა ტიპები

იმისდა მიხედვით თუ რა სახის ინფორმაციას ვიმახსოვრებთ, მისი მეხსიერებაში ჩაწერა ხდება სხვაგვარად:
მაგალითად, თუ გვაქვს მთელი რიცხვები მისთვის სხვა სახით გამოიყოფა მეხსიერება, ხოლო თუ გვაქვს ტექსტი (string), 
ცხადია მისთის სხვა სახით მოხდება მეხსიერების გამოყოფა. გარდა ამისა იმისდა მიხედვით თუ რა სახის ინფორმაციაა, მასზე მათემატიკური თუ
ლოგიკური ოპერაციები ხდება სხვადასხვანაირად.


პითონში გვაქვს შემდეგი მონაცემთა ტიპები:

*** მარტივი ტიპები
int - მთელი რიცხვები (ინგლისურად Integer)
float - ათწილადი რიცხვები
complex - კომპლექსური რიცხვები
string - ტექსტი სიმბოლოების ნაკრები
bool - ბულის ტიპის ცვლადები

გავარჩიოთ თითოეული ცალცალკე:

int-ის ტიპს მიეკუთვნება შემდეგი რიცხვები 1, 2, 3, 0, 19, 100, 1239848, და ა.შ.
ამასთან პითონში int-ისთვის რიცხვის ზომა შეუზღუდავია შესაძლებელია ნებისმიერნიშნა რიცხვის ჩაწერა ცვლადში, თუ რათქმაუნსა არის საკმარისი
ოპერატიული მეხსიერება კომპიუტერში.

float-ის ტიპს მიეკუთვნება ყველა ათწილადი რიცხვი, როგორიცაა 0.1234, 0.04328, 43.15, 3.3333 და ა.შ.
პითონში ათწილადი რიცხვების ზომა განსაზვრულია  დაახლოვებით 1.7976931348623157 გამრავებული 10 ხარისხად -308 და +308 მდე.

complex - კომპლექსური ტიპის ჩანაწერი პითონში არის შემდეგი (23 + 3j) სადაც 23 არის მთელი რიცხვი ხოლო 3 წარმოსახვითი ნაწილი
პითონში კოპლექსური რიხცვებით შეგვიძლია ისევე ვაწარმოოთ მათემატიკური ოპერაციები როგორც მთელი და წილადი რიცხვების შემთხვევაში  

string-ის ტიპს მიეკუთვნება ნებისმიერი ტექსტი, რომელიც მოთავსებულია ერთკბილიანი ან ორკბილიანი ბრჭყალების შიგნით. მაგ.
"ექ23წდკ1aiais sdcsakwkj იჯდიჯდწირჯვჯწს", "This is string text", "532", 'ეს სტრინგია'

bool - ასევე არსებობს ეგრედ წოდებული ბულის ტიპის ცვლადები, რომელმაც შეიძლება მიიღოს მხოლოდ ორი მნიშვნელობა True (ჭეშმარიტი) ან 
False(ცრუ/არაჭეშმარიტი).

მაგ:
გავხსნათ პითონის ინტერაქტიული ინტერპრეტატორი და დავწეროთ შემდეგი

#+BEGIN_SRC bash
>>>b = Ture 
>>>print(b)
True
>>>
>>>b = False
>>>print(b)
False
#+END_SRC


*** შედგენილი ტიპები
გარდა ამისა პითონში არსებობს ე.წ. შედგენილი ტიპები, რომლებსაც შემდგომ განვიხილავთ.
ზოგადად შედგენილი მონაცემთა ტიპებია:

list, tuple, set, dictionary

*** არაფერი - None
რადგან კომპიუტერში ყველაფერი გაზომვადია, დეტერმინირებადია, ამიტომ არაფერსაც აქვს გარკვეული სახელი მინიჭებული.
პითონში ამისთვის არის None.
თუ ცვლადს გამოვაცხადებთ  a = None, ასეთ დროს ცვლადის დასახელება არ მიუთითებს არაფერზე მეხსიერებაში, გარდა იმისა რომ ის არის None ტიპის.

*** ტიპების გარდაქმნა, "type casting"
ზოგიერთ შემთხვევაში რიცხვი მოცემულია სტრინგის სახით, მაგალითად "345" და გვინდა მის მთელ რიცხვად გარდაქმნა. ამისთვის პითონში 
არსებობს ე.წ. ჩაშენებული ფუნქციები (Built-in Functions):

int() ფუნქცია გადაქმნის სტრინგს, წილად რიცხვს მთელ რიცხვად, მაგ: int('23') დააბრუნებს 23, int(3.677) დააბრუნებს 3 და ა.შ.

str() ფუნქცია გარდაქმნის მთელ, წილად ან ნებისმიერ სხვა ტიპს სტრინგად მაგ: str(213) დაბრუნებს "213", str(25.23423) დააბრუნებს '25.23423' 

float() ფუნქცია int ფუნქციის მსგავსად, მაგ: float('34.123') სტრინგს გარდაქმნის და დააბრუნებს  წილად 34.123 რიცხვს, ან float(5) მთელ 5-ს გარდაქმნის
და დააბრუნებს 5.0-ს


...


** ცვლადები

პროგამირების ენებში ცვლადი შეგვიძლია წარმოვიდგინოთ, როგორც რაიმე ადგილი სადაც დროებით ვინახავთ ინფორმაციას. 
გამარტივებითვის კონპიუტერის მეხსიერებას შევადარებ საწყობს, ხოლო ცვლადებს შევადარებ ყუთებს სადაც სხვადასხვა 
სახის ინფორმაციაა მოთავსებული.

ისევე როგორც საწყობში ყველა ყუთს აქვს ზედ დაწერილი უნიკალური დასახელება, ასევე პროგრამის მეხსიერებაში შენახულ ცვლადებსაც აქვს სახელები. 
მოდი ვნახოთ თუ როგორ შეგვიძლია შევქმანთ ცვლადები.

გავხსნათ ინტერაქტიული ინტერპრეტატორი, შევქმანათ ცვლადი და მას მივანიჭოთ რაიმე კონკრეტული სახელი

a = 13

სადაც a არის ცვლადის დასახელება, ხოლო 13 მისი მნიშვნელობა.

print(a)

print(a) ეკრანზე გამოგვიტანს ცვლადის მნიშვნელობას, /ყურადგება მიაქციეთ a-ს ჩანაწერს print-ის შიგნით, ის არ არის ბრჭყალებით ჩაწერილი (როგორც მაგალითად 'hello, world')/
ეს იმიტომ, რომ a ტექსტი კი აღარ არი არამედ, ცვლადის დასახელებაა.

ასევე შეგვიძლია a  ცვლადში შევინახოთ ხვა მნიშვნელობა მაგალითად
#+BEGIN_SRC bash
a = 92
print(a)
#+END_SRC

იგივე სახით ხდება სხვა ტიპის ცვლადისთვის ინფორმაციის მინიჭება, მაგ

#+BEGIN_SRC bash
f = 3.5
print(f)

f = 4.5
print(f)
#+END_SRC

** ლოგიკური ოპერატორები

and -  ლოგიკური "და" ოპერატორი, ადარებს ორ ბულის ტიპს. მაგ:
+ True and True დააბრუნებს True-ს, 
+ True and False დააბრუნებს False-ს, 
+ False and True დააბრუნებს False-ს 
+ False and False დააბრუნებს False-ს 
მარტივად რომ ვთქვათ ლოგიკური "და" ოპერატორით პირობა ჭეშმარიტია თუ ორივე წევრი ჭეშმარიტია.

or -  ლოგიკური "ან" ოპერატორი
+ True or True დააბრუნებს True-ს, 
+ True or False დააბრუნებს True-ს, 
+ False or True დააბრუნებს True-ს 
+ False or False დააბრუნებს False-ს 
ანუ, თუ "ან" ოპერატორის ორივე მხარეს პირობა ცრუა, მაშინ შედეგიც ცრუა, ხოლო ყველა დანარჩენ შემთხვევაში შედეგი ჭეშმარიტია 

not - ლოგიკური "არა" ოპერატორი
მაგ:
+ not True დააბრუნებს False-ს
ხოლო
+ not False დააბრუნებს  True-ს

in - გვიბრუნებს True-ს თუ ობიექტი იმყოფება მეორე ობიექტის შიგნით
not in - in-ის შებრუნებულია
   
** შედარების ოპერატორები

- < - ნაკლბობა 
- <=  ნაკლებია ან ტილია
- >   მეტია
- >=  მეტია ან ტოლია
- ==  ტოლია 
- !=  არ უდრის 
- is  არის, გივეა
- is not არ არის, განსზვავებულია


** მათემატიკური ოპერატორები

პითონით შეგვიძლია მოვახდინოთ მატემეტიკური გამოთვლები როგორიცაა: მიმატება, გამრავლება, გაყოფა, ახარისხება და ა.შ
ჩამოვწეროთ ძირითადი ოპერატორები და მისი მატემატიკური განმარტებები


- +,  მიმატება
- -,  გამოკლება
- *,  გამრავლება
- /,  გაყოფა
- **, ხარისხში აყვანა
- %,  ნაშთი
- //, გაყოფა, რომელიც მოგვცემს მხოლოდ მთელ ნაწილს, 

მაგალითად ინტერაქტიულ ინტერპარეტატორში შეგვიძლია ვცადოთ შემდეგი  

#+BEGIN_SRC bash
>>>3 + 5
8
>>>45 - 5
40
>>>5 * 5
25
>>>12 / 2
6
>>>3 * 3
9
#+END_SRC

ასევე მსგავსი მოქმედებები შეგვიძლია ჩავატაროთ ცვლადების სახითაც 
მაგალითად
#+BEGIN_SRC bash
>>>a = 34
>>>
>>>b = 14
>>>
>>>c = a - b
>>>print(c)
20
#+END_SRC
   
** ბიტებზე მოქმედებები ე.წ. " bitwise ოპერატორები"

- x | y - ბიტის ბიტზე შეკრება - "Bitwise OR" ოპერატორი
- x ^ y - ან გამომრიცხველი - "Bitwise XOR" ოპერატორი
- x & y - ბიტის ბიტზე ლოგიკური გამრავლება - "Bitwise AND" ოპერატორი
- x << n - ბიტების წანაცვლება მარცხნივ n რიგით
- x >> n - ბიტების წანაცვლება მარჯვნივ n რიგით
- ~x    - ბიტებზე ან მოქმედება, მოგცემს x -ის მოპირდაპირე რიცხვს



** პროგრამული ნაკადის კონტროლი, პირობითი ოპერატორები და ციკლები
პროგრამის მუშაობა როგორც ვიცით, ხდება თანმიმდევრობით მაგ: პირველი ბრძანება, მეორე ბრძანება, მესამე და ასე შემდეგ. 
რას ვაკეთებთ იმ შემთხვევაში როდესაც გვინდა რომ პროცესი არ იყოს წრფივი/თანმიმდევრული? მაგალითად შესრულდეს კოდის ერთი მონაკვეთი
რაიმე პირობის დროს და მეორე სხვა პირობის შემთხვევაში, ან შესრულდეს მუდმივი ან გარკვეული პერიოდით. 
სწორედ ამისთვის არის if, while, for სტაიტმენტები.

if, while, for ოპერატორებს აქვს ტანი (თავისი დამოუკიდებელი კოდის შესრულების განყოფილება),

პითონში პირობითი სტაიტმენტია if ოპერატორი, ხოლო ციკლის ტიპის ოპერატორები while და for

*** if სტაიტმენტი
if სტატიმენტი შეგვიძლია წარმოვიდგინოთ როგორც რაიმე გადაწყვეტილების მიღების მექანიზმი მაგალითად:
თუ if-ის პირობაა True(ჭეშმარიტი), მაშინ სრულდება if-ის შიგნით მოთავსებული კოდი, 
ხოლო თუ პირობა False-ია მაშინ მის შიგნით მოთავსებული კოდი არ შესრულდება. 
if ოპერატორს აქვს თავისი დამხმარე ოპერატორი else რომესაც აქვს თავის ბლოკი. else-ს შიგნით კოდი სრულდება იმ შემთხვევაში თუ if-ის პირობა False-ია.
ასევე შესაძლებელია ერთმანეთზე გადაბმული elif (else if) ბლოკების შექმნა, რომელთაგანაც ყველას თავისი პირობა აქვს.

განვიხილოთ კონკრეტული მაგალითი.

ვთქვათ ვწერთ ჭკვიანი სახლის პროგრამას, რომელსაც აქვს შემდეგი მოთხოვნები:
აკოტროლოს ტემპერატურა, განათება, ჩართოს მაღვიძარა და ა.შ.

ასეთ შემთხვევაში პროგრამის ნაწილი შეიძლება დაიწეროს შემდეგნაირად:


#+BEGIN_SRC python 
# გამორთოს გათბობა თუ ტემპერატურა 24 გრადუსზე მეტია
if(temperature > 24):
    heater.off()
# ჩართოს გაგრილება თუ ტემპერატურა 26 გრადუსზე მეტია
elif(temperature > 26):
    cooler.on()
# გამორთოს გაგრილება თუ ტემპერატურა 25 გრადუსზე ნაკლებია
elif(temperature < 25):
    cooler.off()
# თუ არც ერთი პირობა არ დაკმაყოფილდა ჩართოს გათბობა 
else:
    heater.on()
#+END_SRC

*** while ციკლი 
while ციკლი პერიოდულათ ასრულებს მის შიგნით მოცემულ პროგრამას, მანამ სანამ პირობა True (ჭეშმარიტია)
მაგ. 

#+BEGIN_SRC python 
n = 0

while n < 10:
    print('n is less then 10')
    n = n + 1
#+END_SRC

მოცემული პროგრამა დაწერს "n is less then 10"-ს, სანამ n არ გაუტოლდება 10-ს. ამის შემდეგ 
რაც (n < 10) პირობა გახდება False, ციკლი დაასრულებს მუშაობას.

*** for ციკლი

for არის ციკლი რომელიც. ყოველი საფეხურის შესრულების წინ კოლექციიდან იღებს მომდევნო ელემენტს.
განვიხილოთ მაგალითი:

#+BEGIN_SRC python 
# მოცემული მეთოდით კონსოლზე დაიწერება რიცხვები 10 დან 100-მდე 
for n in range(10, 100):
    print(n)  

# ამ შემთხვევაში ყოველი ციკლის შესრულების წინ c-ში ჩაიწერება, ყოველი მომდევნო ასო. კონსოლზე დაიწერება H, e, l, l, o, ,, და ა.შ. ბოლომდე.
for c in 'Hello, from python':
    print(c)

#+END_SRC
